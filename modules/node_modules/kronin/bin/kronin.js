(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*!
*
* Krōnin is a collection of convenient extensions to enhance the Kony SDK.
* https://www.npmjs.com/package/kronin
* @author Miguelángel Fernández.
*/

//This avoids plaguing the editor with EsLint errors for the require, module, exports used by Browserify.
/*eslint no-unused-vars: "warn"*/

},{}],2:[function(require,module,exports){
(function(undefined) {

	var slice = [].slice,
		subscriptions = {};

	var duplicatesAllowed = false;

	function getFunctionBody(func){
		var funcString = func.toString();
		var funcBody = funcString.substring(funcString.indexOf("{"));
		//funcBody = funcBody.replace(/\n/g, '').replace(/\s{2}/g, ' ');
		return funcBody;
	}

	function equalsFunction(f1, f2){
		//If both are named functions.
		if(f1.name && f2.name){
			return f1 === f2;
		}
		//If both are unnamed functions.
		else if (!f1.name && !f2.name){
			return getFunctionBody(f1) === getFunctionBody(f2);
		}
	}

	/**
	 * A pub/sub mechanism taken and adapted from the core module of the
	 * AmplifyJS library.<br>
	 * It allows for total decoupling of event publishers and event subscribers,
	 * and it's particularly useful if events from a single component or module
	 * need to be communicated to several others in the application.
	 * Read more at https://amplifyjs.com/api/pubsub/
	 * */
	kony.amplify = {

		allowDuplicates: function(allow){
			duplicatesAllowed = allow;
		},

		getSubscriptions: function(topic){
			//Generate a read-only copy of the subscriptions.
			return JSON.parse(JSON.stringify(subscriptions[ topic ]));
		},

		isSubscribed: function (topic, callback){
			var found = false;
			for (var i = subscriptions[ topic ].length - 1; i >= 0 ; i--) {

				if(equalsFunction(subscriptions[ topic ][i].callback, callback)){
					found = true;
					break;
				}
			}
			return found;
		},

		publish: function( topic ) {
			if ( typeof topic !== "string" ) {
				throw new Error( "You must provide a valid topic to publish." );
			}

			var args = slice.call( arguments, 1 ),
				topicSubscriptions,
				subscription,
				length,
				i = 0,
				ret;

			if ( !subscriptions[ topic ] ) {
				return true;
			}

			topicSubscriptions = subscriptions[ topic ].slice();
			for ( length = topicSubscriptions.length; i < length; i++ ) {
				subscription = topicSubscriptions[ i ];
				ret = subscription.callback.apply( subscription.context, args );
				if ( ret === false ) {
					break;
				}
			}
			return ret !== false;
		},

		subscribe: function( topic, context, callback, priority ) {
			if ( typeof topic !== "string" ) {
				throw new Error( "You must provide a valid topic to create a subscription." );
			}

			if ( arguments.length === 3 && typeof callback === "number" ) {
				priority = callback;
				callback = context;
				context = null;
			}
			if ( arguments.length === 2 ) {
				callback = context;
				context = null;
			}
			priority = priority || 10;

			var topicIndex = 0,
				topics = topic.split( /\s/ ),
				topicLength = topics.length,
				added;
			for ( ; topicIndex < topicLength; topicIndex++ ) {
				topic = topics[ topicIndex ];
				added = false;
				if ( !subscriptions[ topic ] ) {
					subscriptions[ topic ] = [];
				}

				if(duplicatesAllowed || !this.isSubscribed(topic, callback)){
					var i = subscriptions[ topic ].length - 1,
						subscriptionInfo = {
							callback: callback,
							context: context,
							priority: priority
						};

					for ( ; i >= 0; i-- ) {
						if ( subscriptions[ topic ][ i ].priority <= priority ) {
							subscriptions[ topic ].splice( i + 1, 0, subscriptionInfo );
							added = true;
							break;
						}
					}

					if ( !added ) {
						subscriptions[ topic ].unshift( subscriptionInfo );
					}
				}
			}

			return callback;
		},

		unsubscribe: function( topic, context, callback ) {
			if ( typeof topic !== "string" ) {
				throw new Error( "You must provide a valid topic to remove a subscription." );
			}

			if ( arguments.length === 2 ) {
				callback = context;
				context = null;
			}

			if ( !subscriptions[ topic ] ) {
				return;
			}

			var length = subscriptions[ topic ].length,
				i = 0;

			for ( ; i < length; i++ ) {
				if ( subscriptions[ topic ][ i ].callback === callback ) {
					if ( !context || subscriptions[ topic ][ i ].context === context ) {
						subscriptions[ topic ].splice( i, 1 );

						// Adjust counter and length for removed item
						i--;
						length--;
					}
				}
			}
		}
	};
}());

},{}],3:[function(require,module,exports){
require("./animations");

((definition) => {
	/**
	 * Shortand function to create an animation on an arbitrary property of a widget by
	 * simply providing an initial value and a final value for it, and by using common
	 * default settings such as kony.anim.FILL_MODE_FORWARDS.
	 *
	 * @param {widget} widget Any UI component.
	 * @param {string} animProperty The name of the property in the widget to be animated.
	 * @param {string} initialValue The initial value of the property to be animated.
	 * @param {string} finalValue The final value of the property to be animated.
	 * @param {number} duration How long the animation will take, measured in seconds.
	 * @param {number} delay How long to wait before firing the animation, measured in seconds.
	 * @param {number} timing A constant from kony.anim namespace, defining the acceleration for the animation —e.g. kony.anim.EASE_IN_OUT.
	 */
	kony.animations.animate = definition;
})((
		widget,
		animProperty, initialValue, finalValue,
		duration, delay, timing) => {

	var steps = { 0: {}, 100: {} };
	steps[0][animProperty] = initialValue;
	steps[100][animProperty] = finalValue;
	steps[100].stepConfig = {
		timingFunction: timing || kony.anim.EASE_IN_OUT
	};

	var config = {
		duration: duration || 0.5,
		iterationCount: 1,
		delay: delay || 0.25,
		fillMode: kony.anim.FILL_MODE_FORWARDS
	};

	try{
		var animation = kony.ui.createAnimation(steps);
		widget.animate(animation, config, {
			animationStart: () => {},
			animationEnd: () => {}
		});
	}
	catch(e){
		kony.print(`Problem animating:\n\t${e}`);
	}
});

},{"./animations":4}],4:[function(require,module,exports){
if(typeof kony.animations === "undefined"){
	/**
	 * A namespace for convenience animations.
	 * */
	kony.animations = {};
}

},{}],5:[function(require,module,exports){
require("./animations.animate");

((definition) => {
	/**
	 * Shortand function to create an animation to reveal a widget from opacity 0
	 * to opacity 1, using common default settings such as kony.anim.FILL_MODE_FORWARDS.
	 *
	 * @param {widget} widget Any UI component.
	 * @param {number} duration How long the animation will take, measured in seconds.
	 * @param {number} delay How long to wait before firing the animation, measured in seconds.
	 * @param {number} timing A constant from kony.anim namespace, defining the acceleration for the animation —e.g. kony.anim.EASE_IN_OUT.
	 */
	kony.animations.reveal = definition;
})((widget, duration, delay, timing) => {

	kony.animations.animate(
		widget,
		"opacity", 0, 1,
		duration || 0.5,
		delay || 0.25,
		timing || kony.anim.EASE_IN_OUT
	);
});

},{"./animations.animate":3}],6:[function(require,module,exports){
require("./animations");

((definition) => {
	/**
	 * Create a linear rotation animation without having to create multi-step
	 * animation. This function will dinamically generate all the animation
	 * steps needed to do the rotation and proportionally(as best as possible)
	 * assign each a part of the duration you specify in order to make it as
	 * smooth as possible.
	 *
	 * @param {widget} widget Any UI component.
	 * @param {number} degrees rotation in unsigned degrees.
	 * @param {boolean} clockwise Whether or not the rotation should be clockwise. If not, the rotation will be counter-clockwise.
	 * @param {number} duration The duration of the rotation in seconds. If specified it will override the duration of the Config Object.
	 * @param {object} Config The object containing the duration, delay, iterationCount, direction and fillMode. It's optional and the defaults are duration of 1 second,
	 * delay of 0 seconds, iterationCount 1, direction none, fillMode forwards.
	 * @param {object} callbacks The optional object containing the callbacks for a <widget>.animate() call. If not specified it will default to an empty callbacks object
	 */
	kony.animations.rotate = definition;
})(() => {

	var BREAK_POINT = 90;
	var stepConfig = {timingFunction: kony.anim.LINEAR};

	var DEFAULT_CONFIG = {
		duration: 1,
		delay: 0,
		iterationCount: 1,
		direction: kony.anim.DIRECTION_NONE,
		fillMode: kony.anim.FILL_MODE_FORWARDS
	};

	var DEFAULT_CALLBACKS = {animationEnd: function(){}};

	function _rotate(widget, deg, clockwise, config, callbacks){

		//Calculate how much time should the rotation of each degree last.
		var tick = 100 / deg;
		kony.print("tick:"+tick);

		var steps = {};
		var stepKey = 0;

		var sign = 1;
		clockwise? sign = -1: sign = 1;

		var absRotation = 0;

		//Calculate each step.
		do{
			var rotation = Math.min(deg, BREAK_POINT); //Calculate partial rotation for this step.
			deg = deg - BREAK_POINT; //Calculate how much pending rotation will be left after this step.

			//Prepare transformation with rotation degrees.
			var xfrm = kony.ui.makeAffineTransform();
			absRotation += sign * rotation;
			xfrm.rotate(absRotation);

			//Calculate the key for this step.
			if(deg > 0){
				stepKey += Math.floor(tick * rotation);
			}
			else{ //If this is the last step, the key must be 100.
				stepKey = 100;
			}
			//console.log("key: %s, rotation: %s, absRotation: %s, deg: %s ", stepKey, rotation, absRotation, deg);
			//Add the step to the steps object.
			steps[stepKey] = {
				transform: xfrm,
				stepConfig: stepConfig
			};
		}while(deg > 0);

		kony.print(steps);
		var anim = kony.ui.createAnimation(steps);

		widget.animate(anim, config, callbacks);
	}

	return function(widget, deg, clockwise, duration, _config, _callbacks){
		kony.print("deg: " + deg + ", clockwise: " + clockwise);
		var config, callbacks;
		_config? config = _config: config = DEFAULT_CONFIG;
		_callbacks? callbacks = _callbacks: callbacks = DEFAULT_CALLBACKS;

		if(typeof duration == 'number' && !isNaN(duration) && isFinite(duration)){
			config.duration = duration;
		}

		_rotate(widget, deg, clockwise, config, callbacks);
	};
});

},{"./animations":4}],7:[function(require,module,exports){
((definition) => {
	/**
	* setAppBarColor - Sets the background color of the Android status bar.
	*
	* @param  {String} color An RGB hex-based color code —e.g. #cc0000 for a dark red.
	*/
	kony.application.setAppBarColor = definition;
})((color) => {

	if(typeof color === "undefined" || color.length === 0){
		return;
	}
	if(color[0] !== "#"){
		color = "#" + color;
	}
	if(typeof kony.application.setApplicationProperties === "function"){
		try{
			kony.application.setApplicationProperties({
				statusBarColor: color
			});
		}
		catch(e){
			kony.print(`Error trying to set the app's bar color to ${color}.`);
		}
	}
});

},{}],8:[function(require,module,exports){
(()=>{

	const OS_ANDROID = "android";
	const OS_IOS = "ios";
	const MOBILE_WEB = "mobile_web";

	var os;
	var deviceInfo = kony.os.deviceInfo();

	//TODO: Break this module into one per function.
	function getOs(){
		//#ifdef iphone
		os = OS_IOS;
		kony.print("ifdef iphone: true");
		//alert("ifdef iphone: true");
		//#endif

		//#ifdef android
		os = OS_ANDROID;
		kony.print("ifdef android: true");
		//alert("ifdef android: true");
		//#endif

		if(typeof os === "undefined"){

			// Mobile web -> kony.os.deviceInfo().name === thinclient.
			var message1 = `kony.os.deviceInfo().name: ${deviceInfo.name}\n` +
				  `kony.os.deviceInfo().osname: ${deviceInfo.osname}`;
			kony.print(message1);
			//alert(message1);
			os = deviceInfo.name /*android*/ ||
				deviceInfo.osname /*iPhone*/;
			if(os === "i-phone" || os === "i-pad"){
				os = OS_IOS;
			}
			else if(os === "thinclient"){
				//TODO:This needs more thought. Web is not really an OS.
				os = MOBILE_WEB;
			}
		}
		var message2 = `os: ${os}`;
		kony.print(message2);
		//alert(message2);
		return os;
	}

	kony.os.getOs = getOs;

	kony.os.isIos = () => {
		return getOs() === OS_IOS;
	}

	kony.os.isAndroid = () => {
		return getOs() === OS_ANDROID;
	}

	kony.os.isWeb = () => {
		//TODO: Determine which other values other than thinclient mean it's a web app -e.g. responsive, PWA, desktop web, etc.
		return getOs() === MOBILE_WEB;
	}
})();

},{}],9:[function(require,module,exports){
require("./i18n.getCurrentLocale2");

((definition) => {
	/**
	 * Formats a currency amount by using the decimal separator and digit
	 * grouping appropriate for the current locale.
	 * @param {number} number The number to be formatted.
	 * @param {number} decimalPlaces The number of decimal places required —e.g. formatting 100 with 2 decimal places will result in "100,00" or "100.00" depending on the locale.
	 * @param {string} currency The currency to use in currency formatting. Possible values are the ISO 4217 currency codes —e.g. "EUR" or "USD".
	 * @param {string} currencyDisplay Use "symbol" to display symbols such as € or £, "code" to use the ISO currency code, "name" to use a localized name such as "dollar"; the default is "symbol".
	 * */
	kony.i18n.getCurrencyAmount = definition;
})((number, decimalPlaces, currency, currencyDisplay) => {

	var locale = kony.i18n.getCurrentLocale2();

	/*globals Intl*/
	return new Intl.NumberFormat(locale, {
		style: 'currency',
		currency: currency,
		currencyDisplay: currencyDisplay || "symbol",
		minimumFractionDigits: decimalPlaces,
		maximumFractionDigits: decimalPlaces
	}).format(number);
});

},{"./i18n.getCurrentLocale2":10}],10:[function(require,module,exports){
((definition) => {
	/**
	 * The same as <em>kony.i18n.getCurrentLocale</em> but using a hyphen
	 * instead of an underscore to separate the country and language ISO codes.
	 * */
	kony.i18n.getCurrentLocale2 = definition;
})(() => {
	return kony.i18n.getCurrentLocale().replace("_", "-");
});

},{}],11:[function(require,module,exports){
require("./i18n.getCurrentLocale2");

((definition) => {
	/**
	 * Formats an amount by using the decimal separator and digit
	 * grouping appropriate for the current locale.
	 * @param {number} number The number to be formatted.
	 * @param {number} decimalPlaces The number of decimal places required. The default is 2. —e.g. formatting 100 with 2 decimal places will result in "100,00" or "100.00" depending on the locale.
	 * @param {boolean} asPercentage Whether the amount should be formatted as a percentage or not. The default is false.
	 * */
	kony.i18n.getFormattedAmount = definition;
})((number, decimalPlaces, asPercentage) => {

	var locale = kony.i18n.getCurrentLocale2();

	/*globals Intl*/
	return new Intl.NumberFormat(locale, {
		style: asPercentage ? "percent": "decimal",
		minimumFractionDigits: decimalPlaces || 2,
		maximumFractionDigits: decimalPlaces || 2
	}).format(number);
});

},{"./i18n.getCurrentLocale2":10}],12:[function(require,module,exports){

/**
 * getLocalizedString2 - Get the localised string for an i18n key or return the key itself
 * if no localised string is found for the current locale. This is useful because if there
 * are gaps in a language bundle, seeing the actual key on screen is useful to quickly determine
 * what translations are missing — as opposed to just seeing a blank label and wondering what
 * that is for.
 * This function also supports substitution variables specified with curly brackets — e.g.:
 * If the localised string of an i18n key <em>"LABELS.GREETING"</em> is <em>"Hello {name}"</em>, then the example
 * below will render <em>"Hello Miguel"</em>.
 * @example kony.i18n.getLocalizedString2("LABELS.GREETING", {"name": "Miguel"});
 *
 * @name getLocalizedString2
 * @namespace kony.i18n
 *
 * @author Miguelángel Fernández
 *
 */
((definition) => {
	kony.i18n.getLocalizedString2 = definition;
})(
	/** @lends getLocalizedString2
	 * @param  {String} key   The i18n key to be localised.
	 * @param  {Object} scope Any substitution variables required for the placeholders in the localised string.
	 * @return {String}       The localised string.
	 **/
	function getLocalizedString2(key, scope) {
		var s = kony.i18n.getLocalizedString(key);
		if(!s) return key;

		for (var property in scope) {
			if (scope.hasOwnProperty(property)) {
				s = s.replace(new RegExp("\\{" + property + "\\}", "g"), scope[property]);
			}
		}
		return s;
	}
);

},{}],13:[function(require,module,exports){
require("./i18n.getFormattedAmount");

((definition) => {
	/**
	 * Returns the thousands separator according to the current locale.
	 * */
	kony.i18n.getThousandsSeparator = definition;
})(() => {
	return kony.i18n.getFormattedAmount(1000, 0)[1];
});

},{"./i18n.getFormattedAmount":11}],14:[function(require,module,exports){

require("./aaa");

require("./router");
require("./mvc.wire");

require("./ui.getDescendants");
require("./ui.getComponents");

require("./getOs");
require("./amplify");
require("./application.setAppBarColor");
require("./i18n.getLocalizedString2");
require("./mvc.genAccessors");

require("./i18n.getCurrentLocale2");
require("./i18n.getCurrencyAmount");
require("./i18n.getFormattedAmount");
require("./i18n.getThousandsSeparator");

require("./animations");
require("./animations.rotate");
require("./animations.animate");
require("./animations.reveal");

//Define a global setTimeout function.
require("./setTimeout");

},{"./aaa":1,"./amplify":2,"./animations":4,"./animations.animate":3,"./animations.reveal":5,"./animations.rotate":6,"./application.setAppBarColor":7,"./getOs":8,"./i18n.getCurrencyAmount":9,"./i18n.getCurrentLocale2":10,"./i18n.getFormattedAmount":11,"./i18n.getLocalizedString2":12,"./i18n.getThousandsSeparator":13,"./mvc.genAccessors":15,"./mvc.wire":16,"./router":17,"./setTimeout":18,"./ui.getComponents":19,"./ui.getDescendants":20}],15:[function(require,module,exports){
/*
* Define a component's setters and getters in one line by just listing the fields -e.g.:
* initGettersSetters: function() {kony.mvc.genAccessors(this, ["foo","bar"]);}
*/
((definition) => {
	kony.mvc.genAccessors = definition;
})((compCtrl, fields) => {

	fields.forEach((fieldName) => {
		//The internal field name is prefixed with underscore -e.g.: "_foo" for field "foo"
		var internalFieldName = "_" + fieldName;
		defineGetter(compCtrl, fieldName, function () {
			return compCtrl[internalFieldName];
		});
		defineSetter(compCtrl, fieldName, function (message) {
			compCtrl[internalFieldName] = message;
		});
	});
});

},{}],16:[function(require,module,exports){
require("./router");

((definition) => {
	/**
	 * Wire any init, preShow, postShow, onHide and onOrientationChange
	 * functions in a controller to the form's events, without the need to use
	 * actions or additional code. <br>
	 * It also wraps these functions into try/catch statements so you won't have
	 * to.<br>
	 * Finally, it keeps the <em>kony.router</em> object informed of which form
	 * is the current one.
	 * */
	kony.mvc.wire = definition;

	/**
	 * Deprecated in favour of <em>kony.mvc.wire</em>
	 * */
	kony.mvc.patch = kony.mvc.wire;
})((controller) => {

	if(!controller.patched){
		kony.print(`Kronin is patching ${controller.view.id}`);

		if (!controller.constructor || controller.constructor.name !== "BaseController"){
			throw new Error("Cannot use extension kony.mvc.patch on anything other than a form controller");
		}

		const events = [ //Form events.
			"init",
			//"onDestroy" //Controllers already have their own onDestroy event.
			"preShow",
			"postShow",
			"onHide",
			"onOrientationChange"
		];

		var view = controller.view;
		events.forEach((eventName) => {
			if(typeof controller[eventName] === "function"){
				view[eventName] = function(){
					try{
						//kony.print(`*******Event fired: ${view.id}.${eventName}`);

						//If this is the preShow event of a form, then update current form in router.
						if(eventName === "preShow" && kony.router){
							kony.router.setCurrent(view);
						}
						controller[eventName]();
					}
					catch(e){
						alert(e);
					}
				};
			}
		});
		controller.patched = true; //So we don't patch any controller twice.
	}
});

},{"./router":17}],17:[function(require,module,exports){

((definition) => {
	if(typeof kony.router !== "object"){
		kony.router = definition();
	}
})(function(){

	var history = [];
	var maxH = 5;
	var current;

	function _setCurrent(formId){
		current = formId;
	}
	function _getCurrent(){
		return current;
	}
	function _initHistory(){
		if(typeof history === "undefined"){
			history = [];
		}
		else if(history.length >= 1){
			history = [history[0]];
		}
	}

	function _init(maxHistory){
		_initHistory();
		if(typeof maxHistory !== "undefined" && !isNaN(maxHistory)){
			maxH = maxHistory;
		}
	}

	function _addToHistory(priorForm){

		if(priorForm && priorForm.id){
			var priorId = priorForm.id;
			//If the latest is not already the prior one, then add it.
			if(history.length === 0 || history[history.length - 1] !== priorId){

				//If there's no more roon in the history, remove the oldest after home.
				if(history.length >= maxH){
					history = history.slice(0,1).concat(history.slice(2));
				}
				history.push(priorId);
				//kony.print(`********Added ${priorId} to history. length ${history.length}`);
			}
		}
		else{
			return;
		}
	}

	function _goBack(context){
		if(history.length === 0){
			return;
		}
		else if(history.length === 1){
			_goTo(history[0], context, true);
		}
		else{
			_goTo(history.pop(), context, true);
		}
	}

	function _goHome(context){
		_goTo(history[0], context, true);
		_initHistory();
	}

	function _getHistory(){
		return JSON.parse(JSON.stringify(history));
	}

	function _goTo(friendlyName, context, isGoingBack){

		try{
			//TODO: Make compatible with non-MVC projects.
			(new kony.mvc.Navigation(friendlyName)).navigate(context);

			//Must defer getting the previous form to avoid issues on iOS.
			kony.timer.schedule("kronin-chronicler-" + Date.now(), ()=>{
				var priorForm = kony.application.getPreviousForm();
				if(!isGoingBack)_addToHistory(priorForm);
			}, 0, false);
		}
		catch(e){
			let message = "Can't navigate to form ";
			message +=	`by friendly name '${friendlyName}'\nError: ${e}`;

			//alert(message);
			if(typeof kony.ui.Toast === "undefined"){
				alert(message);
			}
			else{
				var toast = new kony.ui.Toast({
					text:message,
					duration: constants.TOAST_LENGTH_LONG
				});
				toast.show();
			}
		}
	}

	return {
		init: _init,
		goto: _goTo,
		goTo: _goTo,
		getCurrent: _getCurrent,
		setCurrent: _setCurrent,
		goBack: _goBack,
		goHome: _goHome,
		getHistory : _getHistory
	};
});

},{}],18:[function(require,module,exports){
/************************************
 *      MonkeyPatch Timeout         *
 * **********************************
 * Version: 1.0.0
 *
 * Description:
 * Defines the setTimeout and clearTimeout functions for non-browser
 * environments -i.e. Native mobile. This helps the Kony platform play
 * nice with other javascript modules that might depend on these function definitions
 * -e.g. Promises polyfills and Kris Kowal's Q.
 *
 * Implementation Notes:
 * 1) Uses the eval function to avoid declaring a setTimeout or clearTiemout
 * variable/function unless it's necessary. Declaring it and not initializing it
 * will lead to breaking the natively defined namespace on browser environments.
 *
 * 2) Can't wrap in closure notation as there seems to be no global variable -equialent
 * to window or self- in non-browser environments, so there would be nothing to attach
 * it to. Therefore it just has to be declared as a global variable.
 *
 * 3) When used on its own, give this module prefix "aaa" to force this to be loaded before
 * any other javascript libraries that might be dependant setTimeout and clearTimeout
 * being already defined.
 */

var _setTimeout = (function(){ // eslint-disable-line no-unused-vars
	var timeoutId = 7000;
	return function (fn, msDelay){
		kony.timer.schedule(""+timeoutId, fn, msDelay/1000, false);
		return timeoutId++;
	};
})();

var _clearTimeout = function(timeoutId){ // eslint-disable-line no-unused-vars
	kony.timer.cancel(timeoutId);
};

if(typeof window === "undefined" && typeof self === "undefined"){
	eval("var setTimeout = _setTimeout"); // eslint-disable-line no-eval
	eval("var clearTimeout = _clearTimeout"); // eslint-disable-line no-eval
	kony.print("Kronin says: defined setTimeout to: " + setTimeout);
}
else{
	kony.print("Kronin says: setTimeout is natively supported as: " + setTimeout);
}

},{}],19:[function(require,module,exports){
require("./ui.getDescendants.js");

/**
* getComponents - Returns an array containing all the component instances nested
* within a form or container widget. The container widget may be a Form, a Flex
* Container, Scroll Flex Container or any other widget capable of containing components.
*
* @param  {FlexForm|FlexContainer|FlexFormContainer|Segment} containerWidget The parent form or container widget
* for which you wish to get all descendants.
* @param  {Boolean} includeParent   Whether to include the parent container widget in the
* resulting array if it is a component.
* @return {Array} An array containing all components within a form or container widget.
*
* @author Miguelángel Fernández
*/
((definition) => {
	kony.ui.getComponents = definition;
})(function getComponents(containerWidget){

	return kony.ui.getDescendants(containerWidget, false, (child) => {
		//return child.name === "kony.ui.KComponent";
		return child.isMaster || child.name === "kony.ui.KComponent";
	});
});

},{"./ui.getDescendants.js":20}],20:[function(require,module,exports){

/**
* getDescendants - Returns an array containing all the widgets nested within a form or container widget.
* The container widget may be a Form, a Flex Container, Scroll Flex Container or any other widget capable
* of containing other widgets.
*
* @param  {FlexForm|FlexContainer|FlexFormContainer|Segment} containerWidget The parent form or container widget
* for which you wish to get all descendants.
* @param  {Boolean} includeParent   Whether to include the parent container widget in the
* resulting array.
* @param  {Function} test   A function used to determine which children must be included in the result.
* @return {Array} An array containing all widgets within a form or container widget.
*
* @author Miguelángel Fernández
*/
((definition) => {
	kony.ui.getDescendants = definition;
})(function getDescendants(containerWidget, includeParent, test){

	//A function that given a widget, returns its children matching a test
	function getChildren(parent, t){
		var filtered = typeof t === "function";
		var descendants = [];
		if(typeof parent.widgets === "function"){
			let children = parent.widgets();
			if(filtered) children = children.filter(t);
			descendants = descendants.concat(children);
		}
		return descendants;
	}

	//If a widget is considered a descendant of itself, then start by putting it in the array.
	var descendants = includeParent?[containerWidget]:[];
	if(typeof test === "function") descendants = descendants.filter(test);

	//Then add the children of the parent.
	descendants = getChildren(containerWidget, test);

	//Then add the children of each child already known.
	for(var k = 0; k < descendants.length; k++){
		descendants = descendants.concat(getChildren(descendants[k], test));
	}
	return descendants;
});

},{}]},{},[14]);
